"""
Retell Function Calling API Endpoints.

These endpoints are called by Retell's native LLM when it needs to perform
actions like fetching menu data, adding items to cart, or creating orders.

This architecture provides much lower latency than custom WebSocket LLM
because Retell's LLM handles the conversation flow natively.
"""

import os
import json
import hmac
import hashlib
import logging
import uuid
from typing import Dict, Any, Optional, List
from datetime import datetime, timedelta

from fastapi import APIRouter, Request, HTTPException, Depends, Header
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field, field_validator

from backend.database import get_db, SupabaseDB
from backend.services.cart_service import cart_service

router = APIRouter()
logger = logging.getLogger(__name__)


async def verify_retell_request(
    request: Request,
    x_retell_signature: Optional[str] = Header(None, alias="X-Retell-Signature")
) -> bool:
    """
    Verify that the request is coming from Retell.

    Note: Retell's custom tool/function calls are made from Retell's servers
    and may not include signatures like webhooks do. The security is provided
    by the fact that only Retell knows the endpoint URLs configured in the agent.

    For additional security in production, consider:
    - Using a secret token in the URL path
    - IP allowlisting for Retell's servers
    - Request validation via call_id lookup
    """
    # For now, allow all requests to function endpoints
    # These are called by Retell's LLM infrastructure, not directly from users
    # The URLs are only known to Retell (configured in the agent)

    # Log for debugging but don't block
    if x_retell_signature:
        logger.debug(f"Retell function call with signature: {x_retell_signature[:20]}...")

    return True


# ==================== Helper Functions ====================

# Cache for simulation session cart keys
# Maps agent_id -> (cart_key, timestamp)
_simulation_sessions: Dict[str, tuple] = {}
SIMULATION_SESSION_TIMEOUT = 60  # seconds - sessions expire after 1 minute of inactivity


def clear_simulation_session(agent_id: Optional[str]) -> None:
    """Clear the simulation session for an agent after order completion."""
    if agent_id and agent_id in _simulation_sessions:
        del _simulation_sessions[agent_id]
        logger.info(f"Cleared simulation session for agent {agent_id[:12]}")


def get_unique_cart_key(call_id: Optional[str], agent_id: Optional[str], restaurant_id: Optional[int], session_id: Optional[str] = None) -> str:
    """
    Generate a unique cart key for each call/session.

    Priority:
    1. session_id - LLM-generated unique ID per conversation (best for parallel tests)
    2. call_id - Unique for real calls, but "playground" for test simulations
    3. agent_id - Same for all tests using the same agent
    4. restaurant_id - Fallback

    The session_id is generated by the LLM at the start of each conversation,
    ensuring cart isolation even during parallel batch tests.
    """
    # Session ID takes priority - provides isolation for parallel tests
    if session_id:
        return f"session_{session_id}"

    # Real calls have unique call_ids
    if call_id and call_id not in ("playground", "test", "simulation"):
        return call_id

    # For test simulations with agent_id, use agent-based key
    # This maintains cart continuity within a single test
    if agent_id:
        return f"sim_{agent_id[:20]}"

    # Fallback: use "playground" for test simulations
    # This is shared across tests, but tests should handle this
    if call_id == "playground":
        return "playground"

    # Final fallback
    return f"restaurant_{restaurant_id}"


# ==================== Pydantic Models ====================

# Retell sends requests in format: {"call": {...}, "name": "func_name", "args": {...}}
# We need to handle both the nested `args` format from Retell and direct parameters for testing

class RetellCallInfo(BaseModel):
    """Call information from Retell."""
    call_id: Optional[str] = None
    call_type: Optional[str] = None
    agent_id: Optional[str] = None


class GetMenuArgs(BaseModel):
    """Arguments for get_menu function."""
    restaurant_id: Optional[int] = None
    category: Optional[str] = None
    include_prices: Optional[bool] = False  # Only include prices if explicitly asked


class GetMenuRequest(BaseModel):
    """Request to get menu items - handles both Retell format and direct calls."""
    # Retell format fields
    call: Optional[RetellCallInfo] = None
    name: Optional[str] = None
    args: Optional[GetMenuArgs] = None
    # Direct format fields (for testing)
    call_id: Optional[str] = None
    restaurant_id: Optional[int] = None
    category: Optional[str] = None
    include_prices: Optional[bool] = False

    def get_restaurant_id(self) -> Optional[int]:
        """Get restaurant_id from either format."""
        if self.args and self.args.restaurant_id:
            return self.args.restaurant_id
        return self.restaurant_id

    def get_call_id(self) -> Optional[str]:
        """Get call_id from either format."""
        if self.call and self.call.call_id:
            return self.call.call_id
        return self.call_id

    def get_category(self) -> Optional[str]:
        """Get category from either format."""
        if self.args and self.args.category:
            return self.args.category
        return self.category

    def get_include_prices(self) -> bool:
        """Check if prices should be included."""
        if self.args and self.args.include_prices:
            return self.args.include_prices
        return self.include_prices or False


class AddToCartArgs(BaseModel):
    """Arguments for add_to_cart function."""
    restaurant_id: Optional[int] = None
    session_id: Optional[str] = Field(default=None, max_length=20)
    item_name: Optional[str] = Field(default=None, max_length=200)
    quantity: Optional[int] = Field(default=1, ge=1, le=99)
    special_requests: Optional[str] = Field(default=None, max_length=500)


class AddToCartRequest(BaseModel):
    """Request to add item to cart."""
    # Retell format
    call: Optional[RetellCallInfo] = None
    name: Optional[str] = None
    args: Optional[AddToCartArgs] = None
    # Direct format
    call_id: Optional[str] = None
    restaurant_id: Optional[int] = None
    session_id: Optional[str] = Field(default=None, max_length=20)
    item_name: Optional[str] = Field(default=None, max_length=200)
    quantity: int = Field(default=1, ge=1, le=99)
    special_requests: Optional[str] = Field(default=None, max_length=500)

    def get_restaurant_id(self) -> Optional[int]:
        if self.args and self.args.restaurant_id:
            return self.args.restaurant_id
        return self.restaurant_id

    def get_call_id(self) -> Optional[str]:
        if self.call and self.call.call_id:
            return self.call.call_id
        return self.call_id

    def get_agent_id(self) -> Optional[str]:
        if self.call and self.call.agent_id:
            return self.call.agent_id
        return None

    def get_session_id(self) -> Optional[str]:
        if self.args and self.args.session_id:
            return self.args.session_id
        return self.session_id

    def get_item_name(self) -> Optional[str]:
        if self.args and self.args.item_name:
            return self.args.item_name
        return self.item_name

    def get_quantity(self) -> int:
        if self.args and self.args.quantity:
            return self.args.quantity
        return self.quantity

    def get_special_requests(self) -> Optional[str]:
        if self.args and self.args.special_requests:
            return self.args.special_requests
        return self.special_requests


class UpdateCartItemArgs(BaseModel):
    """Arguments for update_cart_item function."""
    restaurant_id: Optional[int] = None
    session_id: Optional[str] = Field(default=None, max_length=20)
    item_name: Optional[str] = None
    quantity: Optional[int] = Field(default=1, ge=1, le=99)


class UpdateCartItemRequest(BaseModel):
    """Request to update item quantity in cart."""
    call: Optional[RetellCallInfo] = None
    name: Optional[str] = None
    args: Optional[UpdateCartItemArgs] = None
    call_id: Optional[str] = None
    restaurant_id: Optional[int] = None
    session_id: Optional[str] = Field(default=None, max_length=20)
    item_name: Optional[str] = None
    quantity: int = Field(default=1, ge=1, le=99)

    def get_restaurant_id(self) -> Optional[int]:
        if self.args and self.args.restaurant_id:
            return self.args.restaurant_id
        return self.restaurant_id

    def get_call_id(self) -> Optional[str]:
        if self.call and self.call.call_id:
            return self.call.call_id
        return self.call_id

    def get_agent_id(self) -> Optional[str]:
        if self.call and self.call.agent_id:
            return self.call.agent_id
        return None

    def get_session_id(self) -> Optional[str]:
        if self.args and self.args.session_id:
            return self.args.session_id
        return self.session_id

    def get_item_name(self) -> Optional[str]:
        if self.args and self.args.item_name:
            return self.args.item_name
        return self.item_name

    def get_quantity(self) -> int:
        if self.args and self.args.quantity:
            return self.args.quantity
        return self.quantity


class RemoveFromCartArgs(BaseModel):
    """Arguments for remove_from_cart function."""
    restaurant_id: Optional[int] = None
    session_id: Optional[str] = Field(default=None, max_length=20)
    item_name: Optional[str] = None


class RemoveFromCartRequest(BaseModel):
    """Request to remove item from cart."""
    call: Optional[RetellCallInfo] = None
    name: Optional[str] = None
    args: Optional[RemoveFromCartArgs] = None
    call_id: Optional[str] = None
    restaurant_id: Optional[int] = None
    session_id: Optional[str] = Field(default=None, max_length=20)
    item_name: Optional[str] = None

    def get_restaurant_id(self) -> Optional[int]:
        if self.args and self.args.restaurant_id:
            return self.args.restaurant_id
        return self.restaurant_id

    def get_call_id(self) -> Optional[str]:
        if self.call and self.call.call_id:
            return self.call.call_id
        return self.call_id

    def get_agent_id(self) -> Optional[str]:
        if self.call and self.call.agent_id:
            return self.call.agent_id
        return None

    def get_session_id(self) -> Optional[str]:
        if self.args and self.args.session_id:
            return self.args.session_id
        return self.session_id

    def get_item_name(self) -> Optional[str]:
        if self.args and self.args.item_name:
            return self.args.item_name
        return self.item_name


class ClearCartArgs(BaseModel):
    """Arguments for clear_cart function."""
    restaurant_id: Optional[int] = None
    session_id: Optional[str] = Field(default=None, max_length=20)


class ClearCartRequest(BaseModel):
    """Request to clear all items from cart."""
    call: Optional[RetellCallInfo] = None
    name: Optional[str] = None
    args: Optional[ClearCartArgs] = None
    call_id: Optional[str] = None
    restaurant_id: Optional[int] = None
    session_id: Optional[str] = Field(default=None, max_length=20)

    def get_restaurant_id(self) -> Optional[int]:
        if self.args and self.args.restaurant_id:
            return self.args.restaurant_id
        return self.restaurant_id

    def get_call_id(self) -> Optional[str]:
        if self.call and self.call.call_id:
            return self.call.call_id
        return self.call_id

    def get_agent_id(self) -> Optional[str]:
        if self.call and self.call.agent_id:
            return self.call.agent_id
        return None

    def get_session_id(self) -> Optional[str]:
        if self.args and self.args.session_id:
            return self.args.session_id
        return self.session_id


class GetCartArgs(BaseModel):
    """Arguments for get_cart function."""
    restaurant_id: Optional[int] = None
    session_id: Optional[str] = Field(default=None, max_length=20)


class GetCartRequest(BaseModel):
    """Request to get current cart."""
    call: Optional[RetellCallInfo] = None
    name: Optional[str] = None
    args: Optional[GetCartArgs] = None
    call_id: Optional[str] = None
    restaurant_id: Optional[int] = None
    session_id: Optional[str] = Field(default=None, max_length=20)

    def get_restaurant_id(self) -> Optional[int]:
        if self.args and self.args.restaurant_id:
            return self.args.restaurant_id
        return self.restaurant_id

    def get_call_id(self) -> Optional[str]:
        if self.call and self.call.call_id:
            return self.call.call_id
        return self.call_id

    def get_agent_id(self) -> Optional[str]:
        if self.call and self.call.agent_id:
            return self.call.agent_id
        return None

    def get_session_id(self) -> Optional[str]:
        if self.args and self.args.session_id:
            return self.args.session_id
        return self.session_id


class CreateOrderArgs(BaseModel):
    """Arguments for create_order function."""
    restaurant_id: Optional[int] = None
    session_id: Optional[str] = Field(default=None, max_length=20)
    customer_name: Optional[str] = Field(default=None, max_length=100)
    pickup_time: Optional[str] = Field(default=None, max_length=50)


class CreateOrderRequest(BaseModel):
    """Request to create/finalize order."""
    call: Optional[RetellCallInfo] = None
    name: Optional[str] = None
    args: Optional[CreateOrderArgs] = None
    call_id: Optional[str] = None
    restaurant_id: Optional[int] = None
    session_id: Optional[str] = Field(default=None, max_length=20)
    customer_name: Optional[str] = Field(default=None, max_length=100)
    pickup_time: Optional[str] = Field(default=None, max_length=50)

    def get_restaurant_id(self) -> Optional[int]:
        if self.args and self.args.restaurant_id:
            return self.args.restaurant_id
        return self.restaurant_id

    def get_call_id(self) -> Optional[str]:
        if self.call and self.call.call_id:
            return self.call.call_id
        return self.call_id

    def get_agent_id(self) -> Optional[str]:
        if self.call and self.call.agent_id:
            return self.call.agent_id
        return None

    def get_session_id(self) -> Optional[str]:
        if self.args and self.args.session_id:
            return self.args.session_id
        return self.session_id

    def get_customer_name(self) -> Optional[str]:
        if self.args and self.args.customer_name:
            return self.args.customer_name
        return self.customer_name

    def get_pickup_time(self) -> Optional[str]:
        if self.args and self.args.pickup_time:
            return self.args.pickup_time
        return self.pickup_time


class GetHoursArgs(BaseModel):
    """Arguments for get_hours function."""
    restaurant_id: Optional[int] = None


class GetHoursRequest(BaseModel):
    """Request to get operating hours."""
    call: Optional[RetellCallInfo] = None
    name: Optional[str] = None
    args: Optional[GetHoursArgs] = None
    call_id: Optional[str] = None
    restaurant_id: Optional[int] = None

    def get_restaurant_id(self) -> Optional[int]:
        if self.args and self.args.restaurant_id:
            return self.args.restaurant_id
        return self.restaurant_id

    def get_call_id(self) -> Optional[str]:
        if self.call and self.call.call_id:
            return self.call.call_id
        return self.call_id


# ==================== Helper Functions ====================

def get_restaurant_id_from_call(call_id: str, db: SupabaseDB) -> Optional[int]:
    """Get restaurant ID associated with a call from Supabase cart."""
    cart = cart_service.get_cart(call_id, db)
    return cart.get("restaurant_id") if cart else None


def get_or_create_cart(call_id: str, restaurant_id: int, db: SupabaseDB, customer_phone: str = None) -> Dict[str, Any]:
    """Get existing cart or create new one in Supabase."""
    return cart_service.get_or_create_cart(call_id, restaurant_id, db, customer_phone)


def lookup_menu_item(item_name: str, menu_data: Dict) -> Optional[Dict]:
    """Look up a menu item by name (fuzzy match)."""
    if not menu_data or not menu_data.get("menus"):
        return None

    item_name_lower = item_name.lower().strip()

    for menu in menu_data.get("menus", []):
        for category in menu.get("categories", []):
            for item in category.get("items", []):
                menu_item_name = item.get("name", "").lower().strip()

                # Check exact match or contains match
                if (menu_item_name == item_name_lower or
                    item_name_lower in menu_item_name or
                    menu_item_name in item_name_lower):
                    return item

                # Check aliases
                for alias in item.get("aliases", []):
                    alias_lower = alias.lower().strip()
                    if alias_lower == item_name_lower or item_name_lower in alias_lower:
                        return item

    return None


def fetch_menu_data(db: SupabaseDB, restaurant_id: int) -> Dict[str, Any]:
    """Fetch full menu data for a restaurant using bulk queries (optimized)."""
    account = db.query_one("restaurant_accounts", {"id": restaurant_id})
    if not account:
        return {}

    menu_data = {
        "business_name": account.get("business_name"),
        "menus": []
    }

    # Bulk fetch all data in 3 queries instead of N+1
    menus = db.query_all("menus", {"account_id": restaurant_id})
    if not menus:
        return menu_data

    menu_ids = [m["id"] for m in menus]
    all_categories = db.query_in("menu_categories", "menu_id", menu_ids)

    category_ids = [c["id"] for c in all_categories]
    all_items = db.query_in("menu_items", "category_id", category_ids) if category_ids else []

    # Build lookup maps for efficient assembly
    categories_by_menu = {}
    for cat in all_categories:
        menu_id = cat["menu_id"]
        if menu_id not in categories_by_menu:
            categories_by_menu[menu_id] = []
        categories_by_menu[menu_id].append(cat)

    items_by_category = {}
    for item in all_items:
        cat_id = item["category_id"]
        if cat_id not in items_by_category:
            items_by_category[cat_id] = []
        items_by_category[cat_id].append(item)

    # Assemble menu structure in memory (no DB queries)
    for menu in menus:
        menu_dict = {
            "id": menu["id"],
            "name": menu["name"],
            "categories": []
        }

        for category in categories_by_menu.get(menu["id"], []):
            category_dict = {
                "id": category["id"],
                "name": category["name"],
                "items": []
            }

            for item in items_by_category.get(category["id"], []):
                category_dict["items"].append({
                    "id": item["id"],
                    "name": item["name"],
                    "description": item.get("description", ""),
                    "price_cents": item.get("price_cents", 0),
                    "price_dollars": item.get("price_cents", 0) / 100,
                    "dietary_tags": item.get("dietary_tags") or [],
                    "aliases": item.get("aliases") or []
                })

            menu_dict["categories"].append(category_dict)
        menu_data["menus"].append(menu_dict)

    return menu_data


def parse_pickup_time(time_str: str) -> tuple[Optional[datetime], str]:
    """Parse pickup time string into datetime and display string."""
    import re

    time_lower = time_str.lower().strip()
    now = datetime.now()
    is_tomorrow = 'tomorrow' in time_lower

    # Handle ASAP
    if time_lower in ["asap", "now", "as soon as possible", "right now"]:
        return None, "ASAP"

    # Handle "in X minutes"
    minutes_match = re.search(r'(\d+)\s*min', time_lower)
    if minutes_match:
        minutes = int(minutes_match.group(1))
        scheduled = now + timedelta(minutes=minutes)
        return scheduled, f"in {minutes} minutes"

    # Handle "in X hours" or "X hours"
    hours_match = re.search(r'(\d+)\s*hour', time_lower)
    if hours_match:
        hours = int(hours_match.group(1))
        scheduled = now + timedelta(hours=hours)
        return scheduled, f"in {hours} hour{'s' if hours > 1 else ''}"

    # Handle "half hour" / "30 minutes"
    if 'half' in time_lower and 'hour' in time_lower:
        scheduled = now + timedelta(minutes=30)
        return scheduled, "in 30 minutes"

    # Handle specific time (e.g., "6pm", "6:30 PM", "tomorrow 5pm")
    time_match = re.search(r'(\d{1,2})(?::(\d{2}))?\s*(am|pm)?', time_lower)
    if time_match:
        hour = int(time_match.group(1))
        minute = int(time_match.group(2)) if time_match.group(2) else 0
        am_pm = time_match.group(3)

        if am_pm == 'pm' and hour < 12:
            hour += 12
        elif am_pm == 'am' and hour == 12:
            hour = 0

        scheduled = now.replace(hour=hour, minute=minute, second=0, microsecond=0)

        # If "tomorrow" was mentioned, add a day
        if is_tomorrow:
            scheduled += timedelta(days=1)
        # If time is in past and tomorrow wasn't mentioned, assume tomorrow
        elif scheduled < now:
            scheduled += timedelta(days=1)

        # Include date in display if not today
        time_display = scheduled.strftime("%I:%M %p").lstrip("0")
        if scheduled.date() == now.date():
            display = f"{time_display} today"
        elif scheduled.date() == (now + timedelta(days=1)).date():
            display = f"{time_display} tomorrow"
        else:
            display = scheduled.strftime("%I:%M %p on %b %d").lstrip("0")
        return scheduled, display

    return None, time_str


# ==================== Function Endpoints ====================

@router.post("/get_menu")
async def get_menu(
    request: GetMenuRequest,
    db: SupabaseDB = Depends(get_db),
    _verified: bool = Depends(verify_retell_request)
):
    """
    Get menu items for the restaurant.
    Called by Retell LLM when customer asks about menu.
    """
    try:
        # Get restaurant_id from request (handles both Retell and direct formats)
        restaurant_id = request.get_restaurant_id()
        call_id = request.get_call_id()
        category = request.get_category()
        include_prices = request.get_include_prices()

        if not restaurant_id and call_id:
            cart = cart_service.get_cart(call_id, db)
            restaurant_id = cart.get("restaurant_id") if cart else None

        if not restaurant_id:
            logger.warning(f"No restaurant_id provided")
            return JSONResponse({
                "success": False,
                "message": "Restaurant not identified. Please try again."
            })

        menu_data = fetch_menu_data(db, restaurant_id)

        # Format menu for voice response
        items_list = []
        categories_found = set()
        for menu in menu_data.get("menus", []):
            for cat in menu.get("categories", []):
                # Filter by category if specified
                if category:
                    if category.lower() not in cat["name"].lower():
                        continue

                categories_found.add(cat["name"])
                for item in cat.get("items", []):
                    items_list.append({
                        "name": item["name"],
                        "price": f"${item['price_dollars']:.0f}",
                        "description": item.get("description", "")[:100],
                        "category": cat["name"]
                    })

        # Build a SHORT, conversational message - just highlight popular items
        if items_list:
            if category:
                # User asked about a specific category - list those items briefly
                cat_items = items_list[:5]
                if include_prices:
                    items_text = ", ".join([f"{i['name']} for {i['price']}" for i in cat_items])
                else:
                    items_text = ", ".join([i['name'] for i in cat_items])
                message = f"We have {items_text}."
                if len(items_list) > 5:
                    message += " And a few more."
            else:
                # General menu question - pick 3 items from different categories, NO PRICES
                # Try to get variety by picking from different categories
                seen_categories = set()
                featured_items = []
                for item in items_list:
                    if item["category"] not in seen_categories and len(featured_items) < 3:
                        featured_items.append(item["name"])
                        seen_categories.add(item["category"])

                # Fill remaining slots if we don't have 3 yet
                if len(featured_items) < 3:
                    for item in items_list:
                        if item["name"] not in featured_items and len(featured_items) < 3:
                            featured_items.append(item["name"])

                if featured_items:
                    categories_text = ", ".join(sorted(seen_categories)[:3]) if len(seen_categories) > 1 else "more"
                    message = f"Popular items include {', '.join(featured_items)}. We also have {categories_text}. What sounds good?"
                else:
                    message = "What are you in the mood for today?"
        else:
            message = "Let me know what you're in the mood for - tacos, burritos, something else?"

        return JSONResponse({
            "success": True,
            "message": message,
            "restaurant_name": menu_data.get("business_name", "the restaurant"),
            "items": items_list[:20],  # Full list available if LLM needs it
            "total_items": len(items_list)
        })

    except Exception as e:
        logger.error(f"Error in get_menu: {e}", exc_info=True)
        return JSONResponse({
            "success": False,
            "message": "Error fetching menu"
        })


@router.post("/add_to_cart")
async def add_to_cart(
    request: AddToCartRequest,
    db: SupabaseDB = Depends(get_db),
    _verified: bool = Depends(verify_retell_request)
):
    """
    Add an item to the customer's cart.
    Called by Retell LLM when customer orders an item.
    """
    try:
        # Get parameters (handles both Retell and direct formats)
        restaurant_id = request.get_restaurant_id()
        call_id = request.get_call_id()
        agent_id = request.get_agent_id()
        session_id = request.get_session_id()
        item_name = request.get_item_name()
        quantity = request.get_quantity()
        special_requests = request.get_special_requests()

        cart_key = get_unique_cart_key(call_id, agent_id, restaurant_id, session_id)

        if not restaurant_id:
            # Try to get from existing cart
            cart = cart_service.get_cart(cart_key, db)
            restaurant_id = cart.get("restaurant_id") if cart else None

        if not restaurant_id:
            return JSONResponse({
                "success": False,
                "message": "Restaurant not identified"
            })

        # Get or create cart in Supabase
        cart = cart_service.get_or_create_cart(cart_key, restaurant_id, db)

        # Look up the menu item
        menu_data = fetch_menu_data(db, restaurant_id)
        menu_item = lookup_menu_item(item_name, menu_data)

        if not menu_item:
            # Return available alternatives
            return JSONResponse({
                "success": False,
                "message": f"'{item_name}' is not on our menu",
                "suggestion": "Please check our menu for available items"
            })

        # Add item using cart service
        items = cart.get("items", [])
        existing_idx = None
        for idx, item in enumerate(items):
            if item.get("name", "").lower() == menu_item["name"].lower():
                existing_idx = idx
                break

        if existing_idx is not None:
            # Update quantity
            items[existing_idx]["quantity"] = items[existing_idx].get("quantity", 1) + quantity
            if special_requests:
                existing_requests = items[existing_idx].get("special_requests", "")
                if existing_requests:
                    items[existing_idx]["special_requests"] = f"{existing_requests}; {special_requests}"
                else:
                    items[existing_idx]["special_requests"] = special_requests
        else:
            # Add new item
            items.append({
                "name": menu_item["name"],
                "quantity": quantity,
                "price_cents": menu_item["price_cents"],
                "special_requests": special_requests or ""
            })

        # Save updated cart to Supabase
        cart_service.save_cart(cart_key, items, db)

        # Get restaurant tax rate
        account = db.query_one("restaurant_accounts", {"id": restaurant_id})
        tax_rate = float(account.get("tax_rate", 0.08)) if account else 0.08

        # Calculate cart total
        subtotal = sum(item["price_cents"] * item["quantity"] for item in items)
        tax = int(subtotal * tax_rate)
        total = subtotal + tax

        logger.info(f"Added to cart: {quantity}x {menu_item['name']} for call {call_id}")

        item_price = menu_item['price_cents'] / 100
        quantity_text = f"{quantity} " if quantity > 1 else ""
        special_text = f" with {special_requests}" if special_requests else ""
        message = f"Got it, {quantity_text}{menu_item['name']}{special_text} for ${item_price:.0f}. Your total is ${total / 100:.0f}. Anything else?"

        return JSONResponse({
            "success": True,
            "message": message,
            "added_item": {
                "name": menu_item["name"],
                "quantity": quantity,
                "price": f"${item_price:.0f}"
            },
            "cart_total": f"${total / 100:.0f}",
            "cart_item_count": sum(item["quantity"] for item in items)
        })

    except Exception as e:
        logger.error(f"Error in add_to_cart: {e}", exc_info=True)
        return JSONResponse({
            "success": False,
            "message": "Error adding item to cart"
        })


@router.post("/update_cart_item")
async def update_cart_item(
    request: UpdateCartItemRequest,
    db: SupabaseDB = Depends(get_db),
    _verified: bool = Depends(verify_retell_request)
):
    """
    Update the quantity of an item in the cart.
    This REPLACES the quantity, not adds to it.
    """
    try:
        restaurant_id = request.get_restaurant_id()
        call_id = request.get_call_id()
        agent_id = request.get_agent_id()
        session_id = request.get_session_id()
        item_name = request.get_item_name()
        new_quantity = request.get_quantity()

        cart_key = get_unique_cart_key(call_id, agent_id, restaurant_id, session_id)
        cart = cart_service.get_cart(cart_key, db)
        if not cart:
            return JSONResponse({
                "success": False,
                "message": "No cart found. Please add an item first."
            })

        items = cart.get("items", [])
        restaurant_id = restaurant_id or cart.get("restaurant_id")

        # Find the item
        item_name_lower = item_name.lower()
        found = False
        for item in items:
            if item.get("name", "").lower() == item_name_lower or item_name_lower in item.get("name", "").lower():
                item["quantity"] = new_quantity
                found = True
                logger.info(f"Updated cart item: {item['name']} to quantity {new_quantity}")
                break

        if not found:
            return JSONResponse({
                "success": False,
                "message": f"I don't see {item_name} in your order. Would you like to add it?"
            })

        # Save updated cart
        cart_service.save_cart(cart_key, items, db)

        # Get restaurant tax rate
        account = db.query_one("restaurant_accounts", {"id": restaurant_id}) if restaurant_id else None
        tax_rate = float(account.get("tax_rate", 0.08)) if account else 0.08

        # Calculate new total
        subtotal = sum(item["price_cents"] * item["quantity"] for item in items)
        tax = int(subtotal * tax_rate)
        total = subtotal + tax

        message = f"Updated to {new_quantity} {item_name}. Your total is ${total / 100:.0f}. Anything else?"

        return JSONResponse({
            "success": True,
            "message": message,
            "updated_item": item_name,
            "new_quantity": new_quantity,
            "cart_total": f"${total / 100:.0f}",
            "cart_item_count": sum(item["quantity"] for item in items)
        })

    except Exception as e:
        logger.error(f"Error in update_cart_item: {e}", exc_info=True)
        return JSONResponse({
            "success": False,
            "message": "Error updating item quantity"
        })


@router.post("/clear_cart")
async def clear_cart(
    request: ClearCartRequest,
    db: SupabaseDB = Depends(get_db),
    _verified: bool = Depends(verify_retell_request)
):
    """
    Clear all items from the cart.
    Used when customer wants to start over.
    """
    try:
        restaurant_id = request.get_restaurant_id()
        call_id = request.get_call_id()
        agent_id = request.get_agent_id()
        session_id = request.get_session_id()

        cart_key = get_unique_cart_key(call_id, agent_id, restaurant_id, session_id)

        # Clear the cart by saving empty items
        cart_service.save_cart(cart_key, [], db)

        logger.info(f"Cleared cart for {cart_key}")

        return JSONResponse({
            "success": True,
            "message": "OK, I've cleared your order. What would you like to get?",
            "cart_total": "$0",
            "cart_item_count": 0
        })

    except Exception as e:
        logger.error(f"Error in clear_cart: {e}", exc_info=True)
        return JSONResponse({
            "success": False,
            "message": "Error clearing cart"
        })


@router.post("/remove_from_cart")
async def remove_from_cart(
    request: RemoveFromCartRequest,
    db: SupabaseDB = Depends(get_db),
    _verified: bool = Depends(verify_retell_request)
):
    """
    Remove an item from the customer's cart.
    """
    try:
        # Get parameters (handles both Retell and direct formats)
        restaurant_id = request.get_restaurant_id()
        call_id = request.get_call_id()
        agent_id = request.get_agent_id()
        session_id = request.get_session_id()
        item_name = request.get_item_name()

        cart_key = get_unique_cart_key(call_id, agent_id, restaurant_id, session_id)
        cart = cart_service.get_cart(cart_key, db)
        if not cart:
            return JSONResponse({
                "success": False,
                "message": "No cart found"
            })

        items = cart.get("items", [])
        restaurant_id = restaurant_id or cart.get("restaurant_id")

        # Find and remove item
        item_name_lower = item_name.lower()
        removed = False
        new_items = []
        for item in items:
            if not removed and (item.get("name", "").lower() == item_name_lower or item_name_lower in item.get("name", "").lower()):
                removed = True
                logger.info(f"Removed from cart: {item.get('name')} for call {call_id}")
            else:
                new_items.append(item)

        if not removed:
            return JSONResponse({
                "success": False,
                "message": f"I don't see {item_name} in your order. Would you like me to tell you what's in your cart?"
            })

        # Save updated cart
        cart_service.save_cart(cart_key, new_items, db)

        # Get restaurant tax rate
        account = db.query_one("restaurant_accounts", {"id": restaurant_id}) if restaurant_id else None
        tax_rate = float(account.get("tax_rate", 0.08)) if account else 0.08

        # Calculate new total
        subtotal = sum(item["price_cents"] * item["quantity"] for item in new_items)
        tax = int(subtotal * tax_rate)
        total = subtotal + tax

        if new_items:
            message = f"Done, I removed the {item_name}. Your new total is ${total / 100:.0f}. Anything else?"
        else:
            message = f"Done, I removed the {item_name}. Your cart is now empty. What would you like to order?"

        return JSONResponse({
            "success": True,
            "message": message,
            "removed_item": item_name,
            "cart_total": f"${total / 100:.0f}",
            "cart_item_count": sum(item["quantity"] for item in new_items)
        })

    except Exception as e:
        logger.error(f"Error in remove_from_cart: {e}", exc_info=True)
        return JSONResponse({
            "success": False,
            "message": "Error removing item"
        })


@router.post("/get_cart")
async def get_cart(
    request: GetCartRequest,
    db: SupabaseDB = Depends(get_db),
    _verified: bool = Depends(verify_retell_request)
):
    """
    Get current cart contents.
    """
    try:
        # Get parameters (handles both Retell and direct formats)
        restaurant_id = request.get_restaurant_id()
        call_id = request.get_call_id()
        agent_id = request.get_agent_id()
        session_id = request.get_session_id()

        cart_key = get_unique_cart_key(call_id, agent_id, restaurant_id, session_id)
        cart = cart_service.get_cart(cart_key, db)
        if not cart or not cart.get("items"):
            return JSONResponse({
                "success": True,
                "items": [],
                "message": "Your cart is empty. What would you like to order?",
                "cart_total": "$0"
            })

        items = cart.get("items", [])
        restaurant_id = restaurant_id or cart.get("restaurant_id")

        # Get restaurant tax rate
        account = db.query_one("restaurant_accounts", {"id": restaurant_id}) if restaurant_id else None
        tax_rate = float(account.get("tax_rate", 0.08)) if account else 0.08

        # Calculate totals
        subtotal = sum(item["price_cents"] * item["quantity"] for item in items)
        tax = int(subtotal * tax_rate)
        total = subtotal + tax

        items_summary = [
            {
                "name": item["name"],
                "quantity": item["quantity"],
                "price": f"${item['price_cents'] * item['quantity'] / 100:.0f}",
                "special_requests": item.get("special_requests", "")
            }
            for item in items
        ]

        # Build speakable message
        items_text = ", ".join([
            f"{item['quantity']} {item['name']}" if item['quantity'] > 1 else item['name']
            for item in items_summary
        ])
        message = f"You have {items_text}. Total is ${total / 100:.0f}. Anything else?"

        return JSONResponse({
            "success": True,
            "message": message,
            "items": items_summary,
            "cart_total": f"${total / 100:.0f}",
            "cart_item_count": sum(item["quantity"] for item in items)
        })

    except Exception as e:
        logger.error(f"Error in get_cart: {e}", exc_info=True)
        return JSONResponse({
            "success": False,
            "message": "Error fetching cart"
        })


@router.post("/create_order")
async def create_order(
    request: CreateOrderRequest,
    db: SupabaseDB = Depends(get_db),
    _verified: bool = Depends(verify_retell_request)
):
    """
    Create/finalize the order.
    Called when customer provides name and pickup time.
    """
    try:
        # Get parameters (handles both Retell and direct formats)
        restaurant_id = request.get_restaurant_id()
        call_id = request.get_call_id()
        agent_id = request.get_agent_id()
        session_id = request.get_session_id()
        customer_name = request.get_customer_name()
        pickup_time = request.get_pickup_time()

        cart_key = get_unique_cart_key(call_id, agent_id, restaurant_id, session_id)
        cart = cart_service.get_cart(cart_key, db)
        if not cart or not cart.get("items"):
            return JSONResponse({
                "success": False,
                "message": "Cart is empty. Please add items first."
            })

        items = cart.get("items", [])
        restaurant_id = restaurant_id or cart.get("restaurant_id")
        if not restaurant_id:
            return JSONResponse({
                "success": False,
                "message": "Restaurant not identified"
            })

        # Get restaurant info
        account = db.query_one("restaurant_accounts", {"id": restaurant_id})
        restaurant = db.query_one("restaurants", {"account_id": restaurant_id})

        if not account or not restaurant:
            return JSONResponse({
                "success": False,
                "message": "Restaurant configuration error"
            })

        # Get or create customer by phone using upsert (atomic, no race condition)
        customer_phone = cart.get("customer_phone", "")
        if not customer_phone:
            customer_phone = "unknown"

        customer = db.upsert("customers", {
            "phone": customer_phone,
            "name": customer_name
        }, on_conflict="phone")

        # Get restaurant tax rate
        tax_rate = float(account.get("tax_rate", 0.08))

        # Calculate totals
        subtotal = sum(item["price_cents"] * item["quantity"] for item in items)
        tax = int(subtotal * tax_rate)
        total = subtotal + tax

        # Parse pickup time
        scheduled_time, pickup_display = parse_pickup_time(pickup_time)

        # Validate advance order days
        max_advance_days = int(account.get("max_advance_order_days", 0))
        if scheduled_time:
            days_ahead = (scheduled_time.date() - datetime.now().date()).days
            if days_ahead > max_advance_days:
                if max_advance_days == 0:
                    return JSONResponse({
                        "success": False,
                        "message": "Sorry, we only accept same-day orders. Would you like to pick up today instead?"
                    })
                else:
                    return JSONResponse({
                        "success": False,
                        "message": f"Sorry, we can only accept orders up to {max_advance_days} day{'s' if max_advance_days > 1 else ''} in advance. Would you like to choose an earlier pickup time?"
                    })

        # Build special instructions from all items
        special_instructions = f"Pickup: {pickup_display}"
        all_requests = []
        for item in items:
            if item.get("special_requests"):
                all_requests.append(f"{item['name']}: {item['special_requests']}")
        if all_requests:
            special_instructions += "\n" + "\n".join(all_requests)

        # Create order
        order_data = {
            "account_id": restaurant_id,
            "restaurant_id": restaurant["id"],
            "customer_id": customer["id"],
            "customer_name": customer_name,
            "customer_phone": cart.get("customer_phone", ""),
            "order_date": datetime.now().isoformat(),
            "scheduled_time": scheduled_time.isoformat() if scheduled_time else None,
            "delivery_address": "Pickup",
            "order_items": json.dumps([
                {
                    "item_name": item["name"],
                    "quantity": item["quantity"],
                    "price_cents": item["price_cents"],
                    "special_requests": item.get("special_requests", "")
                }
                for item in items
            ]),
            "subtotal": subtotal,
            "tax": tax,
            "delivery_fee": 0,
            "total": total,
            "status": "pending",
            "payment_method": "pickup",
            "payment_status": "unpaid",
            "special_instructions": special_instructions,
            "conversation_id": call_id
        }

        # Insert order - cart deletion happens AFTER successful insert (Phase 5 fix)
        order = db.insert("orders", order_data)

        # Build order summary BEFORE deleting cart (in case delete fails, order is still complete)
        items_text = ", ".join([
            f"{item['quantity']} {item['name']}"
            for item in items
        ])

        logger.info(f"Created order #{order['id']} for {customer_name}")

        # Clear the cart from Supabase AFTER successful order creation
        cart_service.delete_cart(cart_key, db)

        # Clear simulation session to ensure next test gets a fresh cart
        clear_simulation_session(agent_id)

        return JSONResponse({
            "success": True,
            "order_id": order["id"],
            "customer_name": customer_name,
            "items_summary": items_text,
            "total": f"${total / 100:.2f}",
            "pickup_time": pickup_display,
            "message": f"Order #{order['id']} confirmed for {customer_name}. {items_text} for ${total / 100:.0f}. Ready for pickup {pickup_display}."
        })

    except Exception as e:
        logger.error(f"Error in create_order: {e}", exc_info=True)
        return JSONResponse({
            "success": False,
            "message": "Error creating order. Please try again."
        })


@router.post("/get_hours")
async def get_hours(
    request: GetHoursRequest,
    db: SupabaseDB = Depends(get_db),
    _verified: bool = Depends(verify_retell_request)
):
    """
    Get restaurant operating hours.
    """
    try:
        # Get parameters (handles both Retell and direct formats)
        restaurant_id = request.get_restaurant_id()
        call_id = request.get_call_id()

        if not restaurant_id and call_id:
            cart = cart_service.get_cart(call_id, db)
            restaurant_id = cart.get("restaurant_id") if cart else None

        if not restaurant_id:
            return JSONResponse({
                "success": False,
                "message": "Restaurant not identified"
            })

        account = db.query_one("restaurant_accounts", {"id": restaurant_id})

        if not account:
            return JSONResponse({
                "success": False,
                "message": "Restaurant not found"
            })

        opening = account.get("opening_time", "N/A")
        closing = account.get("closing_time", "N/A")

        days = account.get("operating_days", [])
        if days and isinstance(days[0], str):
            days_str = ", ".join(days)
        elif days:
            day_names = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
            days_str = ", ".join([day_names[d] for d in sorted(days)])
        else:
            days_str = "every day"

        return JSONResponse({
            "success": True,
            "opening_time": opening,
            "closing_time": closing,
            "operating_days": days_str,
            "message": f"We're open from {opening} to {closing}, {days_str}."
        })

    except Exception as e:
        logger.error(f"Error in get_hours: {e}", exc_info=True)
        return JSONResponse({
            "success": False,
            "message": "Error fetching hours"
        })


class CancelOrderRequest(BaseModel):
    """Request to cancel an order."""
    call: Optional[RetellCallInfo] = None
    name: Optional[str] = None
    args: Optional[Dict[str, Any]] = None
    call_id: Optional[str] = None
    customer_name: Optional[str] = None
    customer_phone: Optional[str] = None

    def get_call_id(self) -> Optional[str]:
        if self.call and self.call.call_id:
            return self.call.call_id
        return self.call_id

    def get_customer_name(self) -> Optional[str]:
        if self.args and self.args.get("customer_name"):
            return self.args["customer_name"]
        return self.customer_name

    def get_restaurant_id(self) -> Optional[int]:
        if self.args and self.args.get("restaurant_id"):
            return int(self.args["restaurant_id"])
        return None

    def get_customer_phone(self) -> Optional[str]:
        if self.args and self.args.get("customer_phone"):
            return self.args["customer_phone"]
        return self.customer_phone


@router.post("/cancel_order")
async def cancel_order(
    request: CancelOrderRequest,
    db: SupabaseDB = Depends(get_db),
    _verified: bool = Depends(verify_retell_request)
):
    """
    Cancel a pending order for a customer.
    Looks up by customer phone (from caller ID) AND customer name for accuracy.
    """
    try:
        call_id = request.get_call_id()
        customer_name = request.get_customer_name()
        restaurant_id = request.get_restaurant_id()

        # Get customer phone from cart (caller ID)
        customer_phone = None
        if call_id:
            cart = cart_service.get_cart(call_id, db)
            customer_phone = cart.get("customer_phone") if cart else None
            # Also get restaurant_id from cart if not provided
            if not restaurant_id and cart:
                restaurant_id = cart.get("restaurant_id")

        if not customer_name:
            return JSONResponse({
                "success": False,
                "message": "I need your name to look up the order. What name was the order under?"
            })

        # Find pending orders - prioritize matching BOTH phone AND name
        orders = []

        # Build query filters - always filter by restaurant if available
        base_filter = {"status": "pending"}
        if restaurant_id:
            base_filter["restaurant_id"] = restaurant_id

        # First try: match both phone and name (most accurate)
        if customer_phone:
            phone_filter = {**base_filter, "customer_phone": customer_phone}
            all_phone_orders = db.query_all("orders", phone_filter, limit=10)
            # Filter by name (case-insensitive partial match)
            orders = [o for o in all_phone_orders if customer_name.lower() in o.get("customer_name", "").lower()]

        # Fallback: search by name only if no phone match (still filtered by restaurant)
        if not orders:
            orders = db.query_all("orders", base_filter, limit=50)
            orders = [o for o in orders if customer_name.lower() in o.get("customer_name", "").lower()]

        if not orders:
            return JSONResponse({
                "success": False,
                "message": f"I couldn't find any pending orders under the name {customer_name}. Are you sure you have an active order?"
            })

        # Cancel the matching order
        order = orders[0]
        db.update("orders", order["id"], {"status": "cancelled"})

        logger.info(f"Cancelled order #{order['id']} for {order.get('customer_name')}")

        return JSONResponse({
            "success": True,
            "order_id": order["id"],
            "message": f"I've cancelled your order for {order.get('customer_name')}. Is there anything else I can help you with?"
        })

    except Exception as e:
        logger.error(f"Error in cancel_order: {e}", exc_info=True)
        return JSONResponse({
            "success": False,
            "message": "Error cancelling order. Please try again."
        })


class EndCallRequest(BaseModel):
    """Request to end the call."""
    call: Optional[RetellCallInfo] = None
    name: Optional[str] = None
    args: Optional[Dict[str, Any]] = None
    call_id: Optional[str] = None
    reason: Optional[str] = None

    def get_reason(self) -> str:
        if self.args and self.args.get("reason"):
            return self.args["reason"]
        return self.reason or "conversation_complete"


@router.post("/end_call")
async def end_call(
    request: EndCallRequest,
    db: SupabaseDB = Depends(get_db),
    _verified: bool = Depends(verify_retell_request)
):
    """
    Signal that the call should end.
    Returns end_call flag for Retell to terminate the call.
    """
    reason = request.get_reason()
    logger.info(f"End call requested: {reason}")

    return JSONResponse({
        "success": True,
        "end_call": True,
        "reason": reason,
        "message": "Thank you for calling. Goodbye!"
    })


# ==================== Call Initialization ====================

@router.post("/init_call")
async def init_call(
    request: Request,
    db: SupabaseDB = Depends(get_db),
    _verified: bool = Depends(verify_retell_request)
):
    """
    Initialize a call with restaurant context.
    Called when a new call starts to set up the cart with restaurant info.
    """
    try:
        data = await request.json()
        call_id = data.get("call_id")
        to_number = data.get("to_number")  # Restaurant's phone number
        from_number = data.get("from_number")  # Customer's phone number

        if not call_id:
            return JSONResponse({"success": False, "message": "Missing call_id"})

        # Look up restaurant by phone number
        restaurant_id = None
        if to_number:
            account = db.query_one("restaurant_accounts", {"retell_phone_number": to_number})
            if account:
                restaurant_id = account["id"]
                logger.info(f"Initialized call {call_id} for restaurant {account['business_name']}")

        # Create cart with restaurant context in Supabase
        cart_service.get_or_create_cart(call_id, restaurant_id, db, from_number)

        return JSONResponse({
            "success": True,
            "call_id": call_id,
            "restaurant_id": restaurant_id
        })

    except Exception as e:
        logger.error(f"Error in init_call: {e}", exc_info=True)
        return JSONResponse({"success": False, "message": str(e)})
